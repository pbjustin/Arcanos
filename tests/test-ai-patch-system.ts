/**
 * Test script for AI Patch System
 * Validates the AI patch system functionality including file operations, Git commits, and retry logic
 */

import { aiPatchSystem, createAIPatch } from '../src/services/ai-patch-system';
import fs from 'fs/promises';
import path from 'path';

async function runBasicTests() {
  console.log('üß™ Running AI Patch System Tests\n');

  // Test 1: Service instantiation and basic validation
  console.log('Test 1: Service instantiation');
  try {
    if (!aiPatchSystem) {
      throw new Error('aiPatchSystem is not instantiated');
    }
    
    if (typeof aiPatchSystem.processPatch !== 'function') {
      throw new Error('processPatch method is not available');
    }
    
    if (typeof createAIPatch !== 'function') {
      throw new Error('createAIPatch helper function is not available');
    }
    
    console.log('‚úÖ AI Patch System service instantiated successfully');
  } catch (error: any) {
    console.error('‚ùå Service instantiation failed:', error.message);
    return;
  }

  // Test 2: Helper function validation
  console.log('\nTest 2: Helper function validation');
  try {
    const testContent = `# Test AI Patch
This is a test patch generated by the AI patch system.

## Features
- Dynamic content handling
- Git integration
- Retry mechanism

Generated at: ${new Date().toISOString()}`;

    const testFilename = `test_patch_${Date.now()}.md`;
    
    // Test the helper function (will likely fail due to auth, but should validate structure)
    const result = await createAIPatch(
      testContent,
      testFilename,
      'Test patch generation'
    );
    
    if (result.success) {
      console.log('‚úÖ Patch created successfully');
      console.log(`   SHA: ${result.sha}`);
      console.log(`   File: ${result.filePath}`);
    } else {
      console.log('‚ö†Ô∏è Expected auth error occurred:', result.error);
    }
    
    console.log('‚úÖ Helper function structure validated');
  } catch (error: any) {
    if (error.message.includes('Bad credentials') || 
        error.message.includes('Not Found') ||
        error.message.includes('GitHub token') ||
        error.message.includes('Git operation failed')) {
      console.log('‚úÖ Helper function validated (expected auth/network error)');
    } else {
      console.error('‚ùå Unexpected error:', error.message);
    }
  }

  // Test 3: File operations (without Git)
  console.log('\nTest 3: Local file operations');
  try {
    const testContent = 'Local test content for AI patch system';
    const testFilename = `local_test_${Date.now()}.txt`;
    const testPath = path.join(process.cwd(), testFilename);
    
    // Test file creation directly
    await fs.writeFile(testPath, testContent, 'utf8');
    
    // Verify file was created
    const readContent = await fs.readFile(testPath, 'utf8');
    if (readContent === testContent) {
      console.log('‚úÖ Local file operations working correctly');
    } else {
      throw new Error('File content mismatch');
    }
    
    // Clean up test file
    await fs.unlink(testPath);
    console.log('‚úÖ Test file cleaned up');
    
  } catch (error: any) {
    console.error('‚ùå Local file operations failed:', error.message);
  }

  // Test 4: System status and retry queue
  console.log('\nTest 4: System status and retry queue');
  try {
    const status = await aiPatchSystem.getSystemStatus();
    
    if (status && typeof status === 'object') {
      console.log('‚úÖ System status retrieved');
      console.log(`   Retry queue length: ${status.retryQueue?.queueLength || 0}`);
      console.log(`   Last success: ${status.lastSuccess ? 'Yes' : 'None'}`);
      console.log(`   Last error: ${status.lastError ? 'Yes' : 'None'}`);
    } else {
      throw new Error('Invalid status response');
    }
    
    // Test retry queue status
    const retryStatus = await aiPatchSystem.getRetryQueueStatus();
    console.log('‚úÖ Retry queue status retrieved');
    console.log(`   Queue items: ${retryStatus.queueLength}`);
    
  } catch (error: any) {
    console.error('‚ùå System status test failed:', error.message);
  }

  // Test 5: Commit message generation
  console.log('\nTest 5: Commit message format validation');
  try {
    // Test commit message format by creating a patch with invalid GitHub config
    // but capture the error to verify message structure
    const testContent = 'Commit message test content';
    const testFilename = 'commit_test.md';
    
    const result = await aiPatchSystem.processPatch({
      content: testContent,
      filename: testFilename,
      taskDescription: 'Testing commit message format'
    });
    
    // Even if it fails, we can verify the error doesn't indicate message format issues
    if (!result.success && result.error) {
      if (result.error.includes('AI patch update') || 
          result.error.includes('Bad credentials') || 
          result.error.includes('Git operation failed')) {
        console.log('‚úÖ Commit message format appears correct (auth error expected)');
      } else {
        console.log('‚ö†Ô∏è Unexpected error format:', result.error);
      }
    } else if (result.success) {
      console.log('‚úÖ Commit message format working (unexpected success)');
    }
    
  } catch (error: any) {
    console.error('‚ùå Commit message test failed:', error.message);
  }

  console.log('\nüéØ AI Patch System Tests Complete');
  console.log('Note: Auth-related failures are expected in test environment');
}

async function runEnvironmentCheck() {
  console.log('\nüîß Environment Check');
  
  const githubToken = process.env.GITHUB_TOKEN;
  const githubOwner = process.env.GITHUB_OWNER || 'pbjustin';
  const githubRepo = process.env.GITHUB_REPO || 'Arcanos';
  
  console.log(`GitHub Token: ${githubToken ? 'Present' : 'Missing'}`);
  console.log(`GitHub Owner: ${githubOwner}`);
  console.log(`GitHub Repo: ${githubRepo}`);
  
  // Check logs directory
  const logsDir = path.join(process.cwd(), 'logs');
  try {
    await fs.access(logsDir);
    console.log('‚úÖ Logs directory exists');
  } catch {
    console.log('‚ö†Ô∏è Logs directory missing - will be created on first use');
  }
}

// Run tests
async function main() {
  await runEnvironmentCheck();
  await runBasicTests();
}

if (require.main === module) {
  main().catch(console.error);
}

export { runBasicTests, runEnvironmentCheck };