/**
 * Test script for AI Patch System
 * Validates the AI patch system functionality including file operations, Git commits, and retry logic
 */
import { aiPatchSystem, createAIPatch } from '../src/services/ai-patch-system';
import fs from 'fs/promises';
import path from 'path';
async function runBasicTests() {
    console.log('üß™ Running AI Patch System Tests\n');
    // Test 1: Service instantiation and basic validation
    console.log('Test 1: Service instantiation');
    try {
        if (!aiPatchSystem) {
            throw new Error('aiPatchSystem is not instantiated');
        }
        if (typeof aiPatchSystem.processPatch !== 'function') {
            throw new Error('processPatch method is not available');
        }
        if (typeof createAIPatch !== 'function') {
            throw new Error('createAIPatch helper function is not available');
        }
        console.log('‚úÖ AI Patch System service instantiated successfully');
    }
    catch (error) {
        console.error('‚ùå Service instantiation failed:', error.message);
        return;
    }
    // Test 2: Helper function validation
    console.log('\nTest 2: Helper function validation');
    try {
        const testContent = `# Test AI Patch
This is a test patch generated by the AI patch system.

## Features
- Dynamic content handling
- Git integration
- Retry mechanism

Generated at: ${new Date().toISOString()}`;
        const testFilename = `test_patch_${Date.now()}.md`;
        // Test the helper function (will likely fail due to auth, but should validate structure)
        const result = await createAIPatch(testContent, testFilename, 'Test patch generation');
        if (result.success) {
            console.log('‚úÖ Patch created successfully');
            console.log(`   SHA: ${result.sha}`);
            console.log(`   File: ${result.filePath}`);
        }
        else {
            console.log('‚ö†Ô∏è Expected auth error occurred:', result.error);
        }
        console.log('‚úÖ Helper function structure validated');
    }
    catch (error) {
        if (error.message.includes('Bad credentials') ||
            error.message.includes('Not Found') ||
            error.message.includes('GitHub token') ||
            error.message.includes('Git operation failed')) {
            console.log('‚úÖ Helper function validated (expected auth/network error)');
        }
        else {
            console.error('‚ùå Unexpected error:', error.message);
        }
    }
    // Test 3: File operations (without Git)
    console.log('\nTest 3: Local file operations');
    try {
        const testContent = 'Local test content for AI patch system';
        const testFilename = `local_test_${Date.now()}.txt`;
        const testPath = path.join(process.cwd(), testFilename);
        // Test file creation directly
        await fs.writeFile(testPath, testContent, 'utf8');
        // Verify file was created
        const readContent = await fs.readFile(testPath, 'utf8');
        if (readContent === testContent) {
            console.log('‚úÖ Local file operations working correctly');
        }
        else {
            throw new Error('File content mismatch');
        }
        // Clean up test file
        await fs.unlink(testPath);
        console.log('‚úÖ Test file cleaned up');
    }
    catch (error) {
        console.error('‚ùå Local file operations failed:', error.message);
    }
    // Test 4: System status and retry queue
    console.log('\nTest 4: System status and retry queue');
    try {
        const status = await aiPatchSystem.getSystemStatus();
        if (status && typeof status === 'object') {
            console.log('‚úÖ System status retrieved');
            console.log(`   Retry queue length: ${status.retryQueue?.queueLength || 0}`);
            console.log(`   Last success: ${status.lastSuccess ? 'Yes' : 'None'}`);
            console.log(`   Last error: ${status.lastError ? 'Yes' : 'None'}`);
        }
        else {
            throw new Error('Invalid status response');
        }
        // Test retry queue status
        const retryStatus = await aiPatchSystem.getRetryQueueStatus();
        console.log('‚úÖ Retry queue status retrieved');
        console.log(`   Queue items: ${retryStatus.queueLength}`);
    }
    catch (error) {
        console.error('‚ùå System status test failed:', error.message);
    }
    // Test 5: Commit message generation
    console.log('\nTest 5: Commit message format validation');
    try {
        // Test commit message format by creating a patch with invalid GitHub config
        // but capture the error to verify message structure
        const testContent = 'Commit message test content';
        const testFilename = 'commit_test.md';
        const result = await aiPatchSystem.processPatch({
            content: testContent,
            filename: testFilename,
            taskDescription: 'Testing commit message format'
        });
        // Even if it fails, we can verify the error doesn't indicate message format issues
        if (!result.success && result.error) {
            if (result.error.includes('AI patch update') ||
                result.error.includes('Bad credentials') ||
                result.error.includes('Git operation failed')) {
                console.log('‚úÖ Commit message format appears correct (auth error expected)');
            }
            else {
                console.log('‚ö†Ô∏è Unexpected error format:', result.error);
            }
        }
        else if (result.success) {
            console.log('‚úÖ Commit message format working (unexpected success)');
        }
    }
    catch (error) {
        console.error('‚ùå Commit message test failed:', error.message);
    }
    console.log('\nüéØ AI Patch System Tests Complete');
    console.log('Note: Auth-related failures are expected in test environment');
}
async function runEnvironmentCheck() {
    console.log('\nüîß Environment Check');
    const githubToken = process.env.GITHUB_TOKEN;
    const githubOwner = process.env.GITHUB_OWNER || 'pbjustin';
    const githubRepo = process.env.GITHUB_REPO || 'Arcanos';
    console.log(`GitHub Token: ${githubToken ? 'Present' : 'Missing'}`);
    console.log(`GitHub Owner: ${githubOwner}`);
    console.log(`GitHub Repo: ${githubRepo}`);
    // Check logs directory
    const logsDir = path.join(process.cwd(), 'logs');
    try {
        await fs.access(logsDir);
        console.log('‚úÖ Logs directory exists');
    }
    catch {
        console.log('‚ö†Ô∏è Logs directory missing - will be created on first use');
    }
}
// Run tests
async function main() {
    await runEnvironmentCheck();
    await runBasicTests();
}
if (require.main === module) {
    main().catch(console.error);
}
export { runBasicTests, runEnvironmentCheck };
