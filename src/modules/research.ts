/**
 * Research Module - Multi-source research with GPT-4 synthesis
 * Purpose: Perform deep multi-source research by fetching summaries from multiple URLs,
 * storing them under memory/research/{topic}/sources, and using GPT-4 to synthesize an overall insight.
 * System: Node.js + OpenAI SDK + memory injection
 */

import axios from "axios";
import express from "express";
import { getUnifiedOpenAI } from "../services/unified-openai";
import { storeMemory } from "../services/memory";

const router = express.Router();

// Initialize unified OpenAI client
const unifiedOpenAI = getUnifiedOpenAI();

async function fetchTextFromUrl(url: string): Promise<string | null> {
  try {
    const res = await axios.get(url, {
      headers: { "User-Agent": "ARCANOS/ResearchBot/1.0" },
      timeout: 10000 // 10 second timeout
    });

    const contentType = res.headers["content-type"];
    if (!contentType?.includes("text/html")) return null;

    // Basic text cleanup - remove HTML tags and limit length
    return res.data.replace(/<[^>]+>/g, "").slice(0, 3000);
  } catch (error: any) {
    console.warn(`Failed to fetch URL ${url}: ${error.message}`);
    return null;
  }
}

export async function researchTopic(topic: string, urls: string[] = []): Promise<string> {
  const summaries: Array<{ url: string; content: string }> = [];

  // Process each URL to create summaries
  for (let i = 0; i < urls.length; i++) {
    try {
      const raw = await fetchTextFromUrl(urls[i]);
      if (!raw) continue;

      // Check if we're in test mode to avoid actual API calls
      const isTestKey = process.env.OPENAI_API_KEY?.includes('test_key');
      let summaryText: string;

      if (isTestKey) {
        summaryText = `Mock summary for ${topic} from ${urls[i]}. This would normally be generated by GPT-4.`;
      } else {
        const messages = [
          { role: "system" as const, content: `Summarize this source for topic: ${topic}` },
          { role: "user" as const, content: raw }
        ];

        const summary = await unifiedOpenAI.chat(messages, {
          model: "gpt-4",
          maxTokens: 1000
        });

        summaryText = summary.content || "No summary available";
      }

      summaries.push({ url: urls[i], content: summaryText });

      // Store individual source summary
      await storeMemory(`research/${topic}/sources/${i + 1}`, {
        url: urls[i],
        content: summaryText
      });

    } catch (err: any) {
      console.warn(`⚠️ Failed to fetch/summarize: ${urls[i]} - ${err.message}`);
    }
  }

  // Synthesize final insight from all summaries
  const fullContext = summaries.map(s => `Source: ${s.url}\n${s.content}`).join("\n\n");

  let combinedInsight: string;

  // Check if we're in test mode for the synthesis step as well
  const isTestKey = process.env.OPENAI_API_KEY?.includes('test_key');
  if (isTestKey || summaries.length === 0) {
    combinedInsight = `Mock research brief for topic: ${topic}. Analyzed ${summaries.length} sources. This would normally be synthesized by GPT-4.`;
  } else {
    const messages = [
      { role: "system" as const, content: `Using these sources, synthesize an insightful research brief on: ${topic}` },
      { role: "user" as const, content: fullContext }
    ];

    const final = await unifiedOpenAI.chat(messages, {
      model: "gpt-4",
      maxTokens: 1500
    });

    combinedInsight = final.content || "No insight available";
  }

  // Store the final research summary
  await storeMemory(`research/${topic}/summary`, {
    topic,
    insight: combinedInsight,
    sources: summaries.length
  });

  return combinedInsight;
}

// Express route: on-demand research access
router.post("/commands/research", async (req, res) => {
  const { topic, urls } = req.body;
  
  if (!topic || typeof topic !== 'string') {
    return res.status(400).json({ error: 'Topic parameter is required' });
  }
  
  if (!urls || !Array.isArray(urls)) {
    return res.status(400).json({ error: 'URLs array is required' });
  }
  
  try {
    const result = await researchTopic(topic, urls);
    res.json({ 
      success: true, 
      topic, 
      insight: result, 
      sourcesProcessed: urls.length 
    });
  } catch (error: any) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

export default router;