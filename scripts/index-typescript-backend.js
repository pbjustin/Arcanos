#!/usr/bin/env node
import { promises as fs } from 'node:fs';
import path from 'node:path';

const REPOSITORY_ROOT = process.cwd();
const OUTPUT_MARKDOWN_PATH = path.join(REPOSITORY_ROOT, 'docs', 'TYPESCRIPT_BACKEND_INDEX.md');
const OUTPUT_JSON_PATH = path.join(REPOSITORY_ROOT, 'backend-typescript-index.json');
const INCLUDED_DIRECTORIES = [
  'src',
  'tests',
  'workers/src',
  'backend-typescript/src',
  'scripts'
];

/**
 * Recursively gathers TypeScript files within one directory tree.
 * @param {string} absoluteDirectoryPath Absolute path of directory to inspect.
 * @returns {Promise<string[]>} Absolute file paths of discovered TypeScript files.
 */
async function collectTypeScriptFilesRecursively(absoluteDirectoryPath) {
  const directoryEntries = await fs.readdir(absoluteDirectoryPath, { withFileTypes: true });
  const collectedFilePaths = [];

  for (const directoryEntry of directoryEntries) {
    const absoluteEntryPath = path.join(absoluteDirectoryPath, directoryEntry.name);

    if (directoryEntry.isDirectory()) {
      //audit Assumption: nested directories may hold backend modules; risk: expensive traversal; invariant: only configured roots are traversed; handling: recurse only within included roots.
      const nestedTypeScriptFiles = await collectTypeScriptFilesRecursively(absoluteEntryPath);
      collectedFilePaths.push(...nestedTypeScriptFiles);
      continue;
    }

    //audit Assumption: only `.ts` and `.d.ts` files are needed for copy-path indexing; risk: missing `.tsx`; invariant: backend is non-React TypeScript; handling: filter by extension and keep declaration files.
    if (directoryEntry.isFile() && directoryEntry.name.endsWith('.ts')) {
      collectedFilePaths.push(absoluteEntryPath);
    }
  }

  return collectedFilePaths;
}

/**
 * Collects and normalizes index entries grouped by configured include roots.
 * @returns {Promise<Array<{scope: string, files: Array<{relativePath: string, absolutePath: string}>}>>} Grouped path entries.
 */
async function buildBackendTypeScriptIndex() {
  const groupedEntries = [];

  for (const includedDirectory of INCLUDED_DIRECTORIES) {
    const absoluteIncludedDirectoryPath = path.join(REPOSITORY_ROOT, includedDirectory);

    try {
      const discoveredFiles = await collectTypeScriptFilesRecursively(absoluteIncludedDirectoryPath);
      const normalizedFileEntries = discoveredFiles
        .map((absoluteFilePath) => {
          const relativeFilePath = path.relative(REPOSITORY_ROOT, absoluteFilePath).split(path.sep).join('/');
          return {
            relativePath: relativeFilePath,
            absolutePath: absoluteFilePath
          };
        })
        .sort((leftEntry, rightEntry) => leftEntry.relativePath.localeCompare(rightEntry.relativePath));

      groupedEntries.push({
        scope: includedDirectory,
        files: normalizedFileEntries
      });
    } catch (error) {
      //audit Assumption: optional directories may not exist in all clones; risk: hard failure blocks index generation; invariant: missing directory should not corrupt existing scopes; handling: continue with empty file list for absent directory.
      if (error && typeof error === 'object' && 'code' in error && error.code === 'ENOENT') {
        groupedEntries.push({
          scope: includedDirectory,
          files: []
        });
        continue;
      }

      throw error;
    }
  }

  return groupedEntries;
}

/**
 * Renders a markdown report with copy-ready relative and absolute paths.
 * @param {Array<{scope: string, files: Array<{relativePath: string, absolutePath: string}>}>} groupedEntries Grouped file entries.
 * @returns {string} Markdown document body.
 */
function renderMarkdownIndex(groupedEntries) {
  const generatedTimestamp = new Date().toISOString();
  const documentLines = [
    '# TypeScript Backend Index',
    '',
    'Generated by `node scripts/index-typescript-backend.js`.',
    '',
    `Generated at: ${generatedTimestamp}`,
    '',
    'This index is copy-path friendly for IDE navigation and shell usage.',
    ''
  ];

  for (const groupedEntry of groupedEntries) {
    documentLines.push(`## ${groupedEntry.scope}`);
    documentLines.push('');

    if (groupedEntry.files.length === 0) {
      documentLines.push('_No TypeScript files found in this scope._');
      documentLines.push('');
      continue;
    }

    documentLines.push('| Relative path (copy for IDE) | Absolute path (copy for terminal) |');
    documentLines.push('| --- | --- |');

    for (const fileEntry of groupedEntry.files) {
      documentLines.push(`| \`${fileEntry.relativePath}\` | \`${fileEntry.absolutePath}\` |`);
    }

    documentLines.push('');
  }

  return `${documentLines.join('\n')}\n`;
}

/**
 * Writes markdown and JSON index artifacts.
 * @returns {Promise<void>} Completes when files are written.
 */
async function writeIndexArtifacts() {
  const groupedEntries = await buildBackendTypeScriptIndex();
  const markdownReport = renderMarkdownIndex(groupedEntries);

  await fs.writeFile(OUTPUT_MARKDOWN_PATH, markdownReport, 'utf-8');
  await fs.writeFile(
    OUTPUT_JSON_PATH,
    `${JSON.stringify({ generatedAt: new Date().toISOString(), scopes: groupedEntries }, null, 2)}\n`,
    'utf-8'
  );

  const totalIndexedFiles = groupedEntries.reduce((fileCount, groupedEntry) => fileCount + groupedEntry.files.length, 0);
  console.log(`[index-typescript-backend] Indexed ${totalIndexedFiles} TypeScript files.`);
  console.log(`[index-typescript-backend] Markdown: ${path.relative(REPOSITORY_ROOT, OUTPUT_MARKDOWN_PATH)}`);
  console.log(`[index-typescript-backend] JSON: ${path.relative(REPOSITORY_ROOT, OUTPUT_JSON_PATH)}`);
}

await writeIndexArtifacts();
